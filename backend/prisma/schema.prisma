// OmniMind Database Schema
// Cognitive Governance Platform

generator client {
  provider = "prisma-client-js"
  output   = "./generated-client"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & IDENTITY
// ============================================

model User {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  email         String   @unique
  passwordHash  String
  displayName   String
  avatarUrl     String?
  role          UserRole @default(USER)
  status        UserStatus @default(ACTIVE)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastLoginAt   DateTime?
  
  // Relations
  experts           Expert[]
  expertVersions    ExpertVersion[]
  debates           Debate[]
  arguments         Argument[]
  reputationScores  ReputationScore[]
  auditEvents       AuditEvent[]
  sessions          Session[]
  
  @@index([status])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  userId       String   @db.ObjectId
  token        String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  ipAddress    String?
  userAgent    String?
  
  user         User     @relation(fields: [userId], references: [id], onDelete: NoAction)
  
  @@index([userId])
}

enum UserRole {
  USER
  REVIEWER
  MODERATOR
  ADMIN
  SUPER_ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

// ============================================
// EXPERT SYSTEM
// ============================================

model Expert {
  id               String       @id @default(auto()) @map("_id") @db.ObjectId
  slug             String       @unique
  currentVersionId String?      @db.ObjectId
  status           ExpertStatus @default(DRAFT)
  createdById      String       @db.ObjectId
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  
  // Relations
  createdBy        User           @relation(fields: [createdById], references: [id])
  versions         ExpertVersion[]
  debates          Debate[]
  
  // Custom M:N relation for dependencies
  // In MongoDB, we model this differently or use an explicit join collection properly mapped
  dependencies     ExpertDependency[] @relation("DependentExpert")
  dependents       ExpertDependency[] @relation("RequiredExpert")
  
  @@index([status])
  @@index([createdById])
}

model ExpertVersion {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  expertId        String   @db.ObjectId
  versionNumber   Int
  scope           Json     // { domain, subdomains, inputTypes, outputTypes, limitations }
  permissions     Json     // { invokeRoles, editRoles, approveRoles, viewRoles }
  logicDefinition Json     // The actual expert logic/rules
  changeReason    String
  createdById     String   @db.ObjectId
  createdAt       DateTime @default(now())
  
  // Metrics (updated periodically)
  accuracyScore   Float    @default(0)
  usageCount      Int      @default(0)
  lastInvokedAt   DateTime?
  
  // Relations
  expert          Expert   @relation(fields: [expertId], references: [id], onDelete: NoAction)
  createdBy       User     @relation(fields: [createdById], references: [id])
  
  @@unique([expertId, versionNumber])
  @@index([expertId])
  @@index([createdById])
}

model ExpertDependency {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  dependentExpertId String   @db.ObjectId
  requiredExpertId  String   @db.ObjectId
  dependencyType    DependencyType @default(REQUIRES)
  createdAt         DateTime @default(now())
  
  dependentExpert   Expert   @relation("DependentExpert", fields: [dependentExpertId], references: [id], onDelete: NoAction)
  requiredExpert    Expert   @relation("RequiredExpert", fields: [requiredExpertId], references: [id], onDelete: NoAction)
  
  @@unique([dependentExpertId, requiredExpertId])
  @@index([dependentExpertId])
  @@index([requiredExpertId])
}

enum ExpertStatus {
  DRAFT
  REVIEW
  ACTIVE
  DEPRECATED
  RETIRED
}

enum DependencyType {
  REQUIRES
  RECOMMENDS
  CONFLICTS
}

// ============================================
// DEBATE & ARGUMENT SYSTEM
// ============================================

model Debate {
  id                  String       @id @default(auto()) @map("_id") @db.ObjectId
  expertId            String       @db.ObjectId
  topic               String
  description         String?
  status              DebateStatus @default(OPEN)
  resolutionCriteria  String
  createdById         String       @db.ObjectId
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt
  resolvedAt          DateTime?
  outcome             Json?        // Resolution details
  
  // Relations
  expert              Expert       @relation(fields: [expertId], references: [id])
  createdBy           User         @relation(fields: [createdById], references: [id])
  arguments           Argument[]
  
  @@index([expertId])
  @@index([status])
  @@index([createdById])
}

model Argument {
  id                    String         @id @default(auto()) @map("_id") @db.ObjectId
  debateId              String         @db.ObjectId
  parentArgumentId      String?        @db.ObjectId
  type                  ArgumentType
  claim                 String
  reasoning             String
  status                ArgumentStatus @default(ACTIVE)
  validationStatus      ValidationStatus @default(PENDING)
  validationReason      String?
  authorReputationAtTime Float
  createdById           String         @db.ObjectId
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  
  // Relations
  debate                Debate         @relation(fields: [debateId], references: [id], onDelete: NoAction)
  parentArgument        Argument?      @relation("ArgumentReplies", fields: [parentArgumentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  childArguments        Argument[]     @relation("ArgumentReplies")
  createdBy             User           @relation(fields: [createdById], references: [id])
  evidence              Evidence[]
  
  @@index([debateId])
  @@index([parentArgumentId])
  @@index([createdById])
  @@index([type])
}

model Evidence {
  id                 String             @id @default(auto()) @map("_id") @db.ObjectId
  argumentId         String             @db.ObjectId
  type               EvidenceType
  content            String
  sourceUrl          String?
  verificationStatus VerificationStatus @default(UNVERIFIED)
  createdAt          DateTime           @default(now())
  
  argument           Argument           @relation(fields: [argumentId], references: [id], onDelete: NoAction)
  
  @@index([argumentId])
}

enum DebateStatus {
  OPEN
  VOTING
  RESOLVED
  STALE
  CLOSED
}

enum ArgumentType {
  CLAIM
  SUPPORT
  COUNTER
  QUESTION
  SYNTHESIS
}

enum ArgumentStatus {
  ACTIVE
  WITHDRAWN
  SUPERSEDED
}

enum ValidationStatus {
  PENDING
  VALIDATED
  DISPUTED
  REFUTED
}

enum EvidenceType {
  CITATION
  DATA
  EXPERT_OUTPUT
  EXTERNAL_LINK
}

enum VerificationStatus {
  UNVERIFIED
  VERIFIED
  DISPUTED
}

// ============================================
// REPUTATION SYSTEM
// ============================================

model ReputationScore {
  id               String   @id @default(auto()) @map("_id") @db.ObjectId
  userId           String   @db.ObjectId
  domain           String
  score            Float    @default(0)
  rank             ReputationRank @default(NOVICE)
  evidenceCount    Int      @default(0)
  accuracyRate     Float    @default(0)
  lastActiveAt     DateTime @default(now())
  lastCalculatedAt DateTime @default(now())
  
  user             User     @relation(fields: [userId], references: [id], onDelete: NoAction)
  history          ReputationEvent[]
  
  @@unique([userId, domain])
  @@index([userId])
  @@index([domain])
  @@index([score])
}

model ReputationEvent {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  reputationScoreId String   @db.ObjectId
  type              ReputationEventType
  delta             Float
  reason            String
  relatedEntityType String?
  relatedEntityId   String?  @db.ObjectId
  createdAt         DateTime @default(now())
  
  reputationScore   ReputationScore @relation(fields: [reputationScoreId], references: [id], onDelete: NoAction)
  
  @@index([reputationScoreId])
  @@index([createdAt])
}

enum ReputationRank {
  NOVICE
  CONTRIBUTOR
  EXPERT
  AUTHORITY
  STEWARD
}

enum ReputationEventType {
  ARGUMENT_VALIDATED
  ARGUMENT_REFUTED
  EXPERT_IMPROVED
  REVIEW_ACCEPTED
  REVIEW_REJECTED
  DECAY
  MANUAL_ADJUSTMENT
}

// ============================================
// AUDIT & GOVERNANCE
// ============================================

model AuditEvent {
  id               String   @id @default(auto()) @map("_id") @db.ObjectId
  timestamp        DateTime @default(now())
  actorId          String?  @db.ObjectId
  actorType        ActorType
  action           String
  resourceType     String
  resourceId       String?  @db.ObjectId
  previousState    Json?
  newState         Json?
  metadata         Json?
  ipAddressHash    String?
  retentionClass   RetentionClass @default(STANDARD)
  sensitivityLevel SensitivityLevel @default(INTERNAL)
  
  actor            User?    @relation(fields: [actorId], references: [id])
  
  @@index([actorId])
  @@index([timestamp])
  @@index([action])
  @@index([resourceType, resourceId])
}

model SystemSetting {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt
  updatedBy String?  @db.ObjectId
}

enum ActorType {
  USER
  SYSTEM
  AUTOMATED_JOB
}

enum RetentionClass {
  STANDARD
  EXTENDED
  PERMANENT
}

enum SensitivityLevel {
  PUBLIC
  INTERNAL
  CONFIDENTIAL
}
